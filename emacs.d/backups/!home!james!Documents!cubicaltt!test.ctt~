module test where

data Nat = Z | S (n : Nat)

Id (A : U) (x y : A) : U = IdP (<i> A) x y
refl (A : U) (a : A) : Id A a a = <i> a
mapOnPath (A B : U) (f : A -> B) (x y : A) (p : Id A x y) : Id B (f x) (f y) =
  <i> f (p @ i)
inv (A : U) (a b : A) (p : Id A a b) : Id A b a = <i> p @ -i
transitive (A : U) (a b c : A) (p : Id A a b) (q : Id A b c) : Id A a c =
  <i> comp A (p @ i) [ (i = 1) -> q ]

compose (A B C : U) (f : B -> C) (g : A -> B) (a : A) : C = f (g a)
id (A : U) (a : A) : A = a

succ (n : Nat) : Nat = S n

add : Nat -> Nat -> Nat = split
  Z -> id Nat
  S m -> compose Nat Nat Nat succ (add m)

addZeroRightNeutral : (m : Nat) -> Id Nat (add m Z) m = split
  Z -> refl Nat Z
  S m -> mapOnPath Nat Nat succ (add m Z) m (addZeroRightNeutral m)

addSuccRightSucc : (m : Nat) -> (n : Nat) -> Id Nat (add m (S n)) (S (add m n)) = split
  Z -> \(n : Nat) -> refl Nat (S n)
  S m -> \(n : Nat) -> mapOnPath Nat Nat succ (add m (S n)) (S (add m n)) (addSuccRightSucc m n)

addCommutative : (m : Nat) -> (n : Nat) -> Id Nat (add n m) (add m n) = split
  Z -> \(n : Nat) -> addZeroRightNeutral n
  S m -> \(n : Nat) -> transitive Nat (add n (S m)) (S (add n m)) (S (add m n)) (addSuccRightSucc n m) (mapOnPath Nat Nat succ (add n m) (add m n) (addCommutative m n))

add' (m : Nat) : Nat -> Nat = split
  Z -> m
  S n -> S (add' m n)
