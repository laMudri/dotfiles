module BinomialHeap
import Data.HVect
import Control.Isomorphism
%default total

{-
data BinomialTree : Nat -> Type -> Type where
  ZTree : a -> BinomialTree Z a
  STree : (topTree,bottomTree : BinomialTree n a) -> BinomialTree (S n) a
%name BinomialTree t,s,r

data BinomialHeap : Nat -> Type -> Type where
  ZHeap : BinomialHeap Z a
  SHeap : Maybe (BinomialTree n a) -> BinomialHeap n a -> BinomialHeap (S n) a
%name BinomialHeap h,i,j

lteAndNotEqual : LTE m n -> Not (m = n) -> LT m n
lteAndNotEqual {m = Z} {n = Z} LTEZero f = void (f Refl)
lteAndNotEqual {m = Z} {n = S k} LTEZero f = LTESucc LTEZero
lteAndNotEqual {m = S j} {n = S k} (LTESucc x) f =
  LTESucc (lteAndNotEqual x (f . cong))

instance Uninhabited (LT m Z) where
  uninhabited LTEZero impossible

succAtPower : BinomialTree m a -> BinomialHeap n a -> {auto p : LTE m n} ->
              Either (BinomialHeap n a) (BinomialHeap (S n) a)
succAtPower {m} {n} t h {p} with (decEq m n)
  succAtPower {m = m} {n = m} t h {p = p} | (Yes Refl) = ?succAtPower_rhs_3
  succAtPower {m = m} {n = Z} t ZHeap {p = p} | (No contra) =
    let ltPrf = lteAndNotEqual p contra in absurd ltPrf
  succAtPower {m = m} {n = S k} t (SHeap x h) {p = p} | (No contra) =
    let ltPrf = lteAndNotEqual p contra in ?succAtPower_rhs_2

merge : BinomialHeap m a -> BinomialHeap n a -> (k ** BinomialHeap k a)
merge {m} {n} h i with (isLTE m n)
  merge {m = m} {n = n} h i | (Yes prf) = ?merge_rhs_1
  merge {m = m} {n = n} h i | (No contra) = ?merge_rhs_2

--iota : (n : Nat) -> Vect n Nat
--
--BinomialHeap : Nat -> Type -> Type
--BinomialHeap n a = HVect (map (Maybe . flip BinomialTree a) (iota n))

data PartialBinomialHeap : Nat -> Nat -> Type -> Type where
  ZPartHeap : PartialBinomialHeap m Z a
  SPartHeap : Maybe (BinomialTree m a) -> PartialBinomialHeap (S m) n a ->
              PartialBinomialHeap m n a
%name PartialBinomialHeap ph,pi,pj

partialBinomialHeapIso : Iso (BinomialHeap n a) (PartialBinomialHeap n n a)
partialBinomialHeapIso {n} {a} = MkIso to from toFrom fromTo
  where
    X : Type
    X = BinomialHeap n a
    Y : Type
    Y = PartialBinomialHeap n n a
    to : X -> Y
    from : Y -> X
    toFrom : (y : Y) -> to (from y) = y
    fromTo : (x : X) -> from (to x) = x

root : BinomialTree n a -> a
root (ZTree x) = x
root (STree topTree bottomTree) = root topTree

addTrees : Ord a => BinomialTree n a -> BinomialTree n a -> BinomialTree (S n) a
addTrees t s =
  if root t < root s
    then STree t s
    else STree s t

addMaybeTrees : Ord a => Maybe (BinomialTree n a) -> Maybe (BinomialTree n a) ->
                         Maybe (BinomialTree n a `Either` BinomialTree (S n) a)
addMaybeTrees Nothing Nothing = Nothing
addMaybeTrees Nothing (Just y) = Just (Left y)
addMaybeTrees (Just x) Nothing = Just (Left x)
addMaybeTrees (Just x) (Just y) = Just (Right (addTrees x y))

mergePartial : Ord a => PartialBinomialHeap m i a ->
                        PartialBinomialHeap m j a ->
                        (k ** PartialBinomialHeap m k a)
mergePartial {j} ZPartHeap pj = MkSigma j pj
mergePartial {i} pi ZPartHeap = MkSigma i pi
mergePartial (SPartHeap x pi) (SPartHeap y pj) with (addMaybeTrees x y)
  mergePartial (SPartHeap x pi) (SPartHeap y pj) | Nothing =
    let MkSigma _ pij = mergePartial pi pj in MkSigma _ $ SPartHeap Nothing pij
  mergePartial (SPartHeap x pi) (SPartHeap y pj) | (Just (Left z)) = ?mergePartial_rhs_3
  mergePartial (SPartHeap x pi) (SPartHeap y pj) | (Just (Right z)) = ?mergePartial_rhs_4
-}

mutual
  Children : Nat -> Type -> Type
  Children Z a = Unit
  Children (S k) a = BinomTree k a `Pair` Children k a

  BinomTree : Nat -> Type -> Type
  BinomTree n a = a `Pair` Children n a

addTrees' : Ord a => BinomTree n a -> BinomTree n a -> BinomTree (S n) a
addTrees' (r0, cs0) (r1, cs1) =
  if r0 < r1
    then (r0,(r1,cs1),cs0)
    else (r1,(r0,cs0),cs1)

data PartialBinomHeap : Nat -> Nat -> Type -> Type where
  NilPartHeap : PartialBinomHeap m Z a
  ConsPartHeap : Maybe (BinomTree m a) -> PartialBinomHeap (S m) n a ->
                 PartialBinomHeap m (S n) a

appendPartHeap : PartialBinomHeap i j a -> PartialBinomHeap (j + i) k a ->
                 PartialBinomHeap i (j + k) a
appendPartHeap NilPartHeap z = z
appendPartHeap {j = S n} {i} (ConsPartHeap x y) z =
  ConsPartHeap x (appendPartHeap y (rewrite sym $ plusSuccRightSucc n i in z))

emptyPartHeap : (m,n : Nat) -> PartialBinomHeap m n a
emptyPartHeap m Z = NilPartHeap
emptyPartHeap m (S n) = ConsPartHeap Nothing (emptyPartHeap (S m) n)

singletonPartHeap : BinomTree n a -> PartialBinomHeap n 1 a
singletonPartHeap x = ConsPartHeap (Just x) NilPartHeap

childrenToPartHeap : Children n a -> PartialBinomHeap Z n a
childrenToPartHeap {n = Z} x = NilPartHeap
childrenToPartHeap {n = S k} (x,xs) =
  let y = appendPartHeap (childrenToPartHeap xs) (singletonPartHeap (f x)) in
  g y
  where
    f : BinomTree n a -> BinomTree (n + 0) a
    f {n} t = rewrite plusZeroRightNeutral n in t

    g : PartialBinomHeap Z (n + 1) a -> PartialBinomHeap Z (S n) a
    g {n} x =
      rewrite sym $ plusZeroRightNeutral (S n) in
      rewrite plusSuccRightSucc n Z in
      x

removeRoot : BinomTree n a -> PartialBinomHeap Z n a
removeRoot (root,children) = childrenToPartHeap children
