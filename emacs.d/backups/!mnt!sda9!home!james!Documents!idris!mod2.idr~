module mod2
  data Mod : Nat -> Type where
    mkMod : Fin m -> Mod m
  
  total
  natToFin : (j : Nat) -> {auto p : j `LT` n} -> Fin n
  natToFin {n = (S k)} Z = FZ
  natToFin {n = (S k)} (S j) {p = (LTESucc x)} = FS (natToFin j)
  
  partial
  buildProof : (j : Nat) -> (n : Nat) -> j `LT` n
  buildProof Z (S k) = LTESucc LTEZero
  buildProof (S k) (S j) = LTESucc (buildProof k j)

  natToMod : (j : Nat) -> {default (buildProof j n) p : j `LT` n} -> Mod n
  natToMod {p} = mkMod . natToFin {p = p}
  
  total notLTZero : (m : Nat) -> m `LT` Z -> Void
  total LTSuccContra : Not (j `LT` k) -> S j `LT` S k -> Void
  
  decLT : (m : Nat) -> (n : Nat) -> Dec (m `LT` n)
  decLT m Z = No $ notLTZero m
  decLT Z (S k) = Yes (LTESucc LTEZero)
  decLT (S j) (S k) with (decLT j k)
    decLT (S j) (S k) | (Yes prf) = Yes (LTESucc prf)
    decLT (S j) (S k) | (No contra) = No (LTSuccContra contra)
  
  coerceNatToMod : Nat -> Mod n
  coerceNatToMod {n} k with (decLT k n)
    coerceNatToMod k | (Yes prf) = natToMod k
    coerceNatToMod {n} k | (No contra) = coerceNatToMod (k - n)

  {-natToMod : {m : Nat} -> Nat -> Mod m
  natToMod {m} k with (choose (k < m))
    natToMod k | (Left Oh) = mkMod k
    natToMod {m} k | (Right Oh) = natToMod (k - m)-}
  
  {-plus : Mod m -> Mod m -> Mod m
  plus {m} (mkMod j) (mkMod k) with (choose (j + k < m))
    plus (mkMod j) (mkMod k) | (Left Oh) = mkMod (j + k)
    plus {m} (mkMod j) (mkMod k) | (Right Oh) = mkMod (j + k - m)
                                                      {p=?plus_proof}-}
  
  
 
 
