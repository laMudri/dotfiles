module mod2
  data Mod : Nat -> Type where
    mkMod : {m : Nat} -> (n : Fin m) -> Mod m
  
  natToFin : (j : Nat) -> {auto p : So (j < n)} -> Fin n
  natToFin Z = ?rhs_1
  natToFin (S k) = ?rhs_2

  {-natToMod : {m : Nat} -> Nat -> Mod m
  natToMod {m} k with (choose (k < m))
    natToMod k | (Left Oh) = mkMod k
    natToMod {m} k | (Right Oh) = natToMod (k - m)-}
  
  {-plus : Mod m -> Mod m -> Mod m
  plus {m} (mkMod j) (mkMod k) with (choose (j + k < m))
    plus (mkMod j) (mkMod k) | (Left Oh) = mkMod (j + k)
    plus {m} (mkMod j) (mkMod k) | (Right Oh) = mkMod (j + k - m)
                                                      {p=?plus_proof}-}
  
  
 
