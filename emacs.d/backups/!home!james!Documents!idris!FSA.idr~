module DFA
import Data.Fin
%default total
data Finite : Nat -> Type -> Type where
  MkFinite : {a : Type} -> (toFin,fromFin : _) ->
             ((x :     a) -> x = fromFin (toFin x)) ->
             ((y : Fin n) -> y = toFin (fromFin y)) ->
             Finite n a
data DFA : Type -> Type -> Type where
  MkDFA : Finite m a -> Finite n s -> (start : s) -> (delta : s -> a -> s) ->
          (finish : s -> Dec s) -> DFA a s
%name DFA m

BoolFinite : Finite 2 Bool
BoolFinite = MkFinite toFin fromFin prf0 prf1
  where
    toFin : Bool -> Fin 2
    toFin False = FZ
    toFin True = FS FZ

    fromFin : Fin 2 -> Bool
    fromFin FZ = False
    fromFin (FS FZ) = True
    fromFin (FS (FS x)) = absurd x

    prf0 : (x : Bool) -> x = fromFin (toFin x)
    prf0 False = Refl
    prf0 True = Refl

    prf1 : (y : Fin 2) -> y = toFin (fromFin y)
    prf1 FZ = Refl
    prf1 (FS FZ) = Refl
    prf1 (FS (FS x)) = absurd x

FinFinite : Finite n (Fin n)
FinFinite = MkFinite id id (\x => Refl) (\y => Refl)

runDFA : DFA a s -> List a -> s
runDFA (MkDFA x y start delta finish) [] = start
runDFA (MkDFA x y start delta finish) (c :: cs) =
  runDFA (MkDFA x y (delta start c) delta finish) cs

matchDFA : DFA a s -> List a -> Dec s
matchDFA m@(MkDFA x y start delta finish) xs = finish $ runDFA m xs
