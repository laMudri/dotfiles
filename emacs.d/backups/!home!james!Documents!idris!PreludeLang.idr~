module PreludeLang
import Data.Fin
import Data.Vect

total
natToFinSparing : (m : Nat) -> (n : Nat) -> Fin (m + S n)
natToFinSparing Z n = FZ
natToFinSparing (S k) n = FS (natToFinSparing k n)

data VectZipper : Vect n a -> Fin n -> Type where
  MkZip : (xs : Vect m a) -> (y : a) -> (zs : Vect n a) ->
          VectZipper (xs ++ y :: zs) (natToFinSparing m n)

data Token = Add | Sub | Disc | Open | Close | Above | Below | Input | Output
           | Num Integer | Nop
data Error = EmptyStack
data Motion = Next | StartLoop | EndLoop

total
convertInput : Char -> Integer
convertInput = cast . ord

total
convertOutput : Integer -> Char
convertOutput = chr . fromInteger

total
interpPoint : Maybe Integer -> Maybe Integer -> List Integer -> Token ->
              IO (Error `Either` (List Integer `Pair` Motion))
interpPoint ab bel (a :: b :: cs) Add = return (return ((a + b) :: cs, Next))
interpPoint ab bel _ Add = return (Left EmptyStack)
interpPoint ab bel (a :: b :: cs) Sub = return (return ((b - a) :: cs, Next))
interpPoint ab bel _ Sub = return (Left EmptyStack)
interpPoint ab bel (x :: xs) Disc = return (return (xs, Next))
interpPoint ab bel _ Disc = return (Left EmptyStack)
interpPoint ab bel xs Open = return (return (xs, StartLoop))
interpPoint ab bel (x :: xs) Close =
  return (return (x :: xs, if x == 0 then Next else EndLoop))
interpPoint ab bel _ Close = return (Left EmptyStack)
interpPoint (Just ab) bel xs Above = return (return (ab :: xs, Next))
interpPoint _ bel xs Above = return (Left EmptyStack)
interpPoint ab (Just bel) xs Below = return (return (bel :: xs, Next))
interpPoint ab _ xs Below = return (Left EmptyStack)
interpPoint ab bel xs Input = [return (convertInput res :: xs, Next) |
                               res <- getChar]
interpPoint ab bel (x :: xs) Output = do
  putChar (convertOutput x)
  return (return (xs, Next))
interpPoint ab bel _ Output = return (Left EmptyStack)
interpPoint ab bel xs (Num x) = return (return (x :: xs, Next))
interpPoint ab bel xs Nop = return (return (xs, Next))

interpColumnWithFirstLast : Maybe Integer -> Maybe Integer ->
                            Vect n (List Integer) -> Vect n Token ->
                            IO (Error `Either`
                                (Vect n (List Integer) `Pair` Motion))
interpColumnWithFirstLast f l [] [] = return (return ([],Next))
interpColumnWithFirstLast f l (xs :: []) (y :: []) = ?rhs
interpColumnWithFirstLast f l (xs :: xs' :: xss) (y :: ys) = do
  res <- interpPoint l (head' xs') xs y
  res0 <- interpColumnWithFirstLast f (head' xs) (xs' :: xss) ys
  ?interpColumn_rhs_1

interpColumn : Vect n (List Integer) -> Vect n Token ->
               IO (Error `Either` (Vect n (List Integer) `Pair` Motion))

partial
interp : List (Fin m) ->
         Vect n (List Integer) ->
         VectZipper {n=m} {a=Vect n Token} xs i ->
         IO (Error `Either`
             (Vect n (List Integer) `Pair` (j ** VectZipper xs j)))
interp js ss (MkZip xss ys zss) = ?interp_rhs_1
