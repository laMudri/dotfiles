module Induction
  %default total
  %hide Prelude.pow
  induct : (P : Nat -> Type) -> P Z -> ((n : Nat) -> (ih : P n) -> P (S n)) ->
           (n : Nat) -> P n
  induct P x f Z = x
  induct P x f (S n) with (induct P x f n)
    induct P x f (S n) | ih = f n ih

  -- Using the combinator
  plusSuccRightSucc' : (x : Nat) -> (y : Nat) -> x + S y = S (x + y)
  plusSuccRightSucc' x y =
    induct (\k => k + S y = S (k + y)) Refl (\n,ih => ?step) x

  -- Using explicit induction (relies on plusCommutative)
  --plusSuccRightSucc'' : (x : Nat) -> (y : Nat) -> x + S y = S (x + y)
  --plusSuccRightSucc'' x Z = ?base'
  --plusSuccRightSucc'' x (S k) with (plusSuccRightSucc'' x k)
  --  plusSuccRightSucc'' x (S k) | ih = ?step'

  plusSuccRightSucc'' : (x : Nat) -> (y : Nat) -> S (x + y) = x + S y
  plusSuccRightSucc'' x =
    induct (\y => S (x + y) = x + S y) ?base' (\n,ih => ?step')

  -- Using just plusCommutative. Circular reasoning, really.
  plusSuccRightSucc''' : (x : Nat) -> (y : Nat) -> x + S y = S (x + y)
  plusSuccRightSucc''' x y = ?plusSuccRightSucc'''_rhs

  powApply : Nat -> (a -> a) -> a -> a
  powApply Z f x = x
  powApply (S k) f x = powApply k f (f x)

  pow : Nat -> Nat -> Nat
  pow = flip power

  doubleLemma : (n : Nat) -> n + n = 2 * n
  doubleLemma n = ?doubleLemma_rhs

  powApplyOtherSide : (n : Nat) -> (f : _) -> (x : _) ->
                      powApply (S n) f x = f (powApply n f x)
  powApplyOtherSide Z f x = Refl
  powApplyOtherSide (S k) f x = powApplyOtherSide k f (f x)

  powersOf2Minus1 : (n : Nat) -> pow n 2 = S (powApply n (S . (2 *)) Z)
  powersOf2Minus1 n =
    induct (\n => pow n 2 = S (powApply n (S . (2 *)) Z)) Refl ?po2_step n

---------- Proofs ----------
Induction.po2_step = proof
  compute
  intro
  intro
  intro
  intro
  intro
  rewrite sym $ powApplyOtherSide n1 (S . (2 *)) 0
  intro
  rewrite sym ih
  rewrite sym $ plusZeroRightNeutral (powApply n1 (S . (2 *)) 0)
  rewrite sym $ plusSuccRightSucc (powApply n1 (S . (2 *)) 0) (powApply n1 (S . (2 *)) 0)
  rewrite sym $ plusZeroRightNeutral (S (powApply n1 (S . (2 *)) 0))
  compute
  rewrite plusCommutative 0 (S (powApply n1 (S . \k => plus k (plus k 0)) 0))
  trivial


Induction.doubleLemma_rhs = proof
  intro
  rewrite sym (plusZeroRightNeutral n)
  trivial

Induction.plusSuccRightSucc'''_rhs = proof
  intros
  rewrite plusCommutative (S y) x
  rewrite plusCommutative x y
  trivial

--Induction.step' = proof
--  intros
--  rewrite sym ih
--  rewrite plusCommutative (S (S k)) x
--  rewrite plusCommutative x k
--  trivial
--
--Induction.base' = proof
--  intros
--  rewrite plusCommutative 1 x
--  rewrite plusCommutative 0 x
--  trivial

Induction.step = proof
  intros
  compute
  rewrite ih
  trivial
