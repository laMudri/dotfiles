\documentclass[11pt]{article}
%Gummi|063|=)
\title{\textbf{Algorithms I -- supervision 2}}
\author{James Wood}
\usepackage{listings}
\usepackage{bold-extra}
\usepackage{xcolor}
\usepackage{enumitem}
\setenumerate[0]{label=(\alph*)}
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\lstset{
  basicstyle=\small,
  basewidth=0.5em,
  frame=single,
  breaklines=true,
  %postbreak=\raisebox{0ex}[0ex][0ex]{
  %  \ensuremath{\color{red}\hookrightarrow\space}
  %}
  language=haskell
}

\begin{document}

\maketitle

\section{Heap sort}
\begin{enumerate}
\item A heap of height \(h\) must contain at least \(\left(\sum_{i\in[0..h)}2^i\right)+1\), which is \(2^h\), elements; it can contain at most \(\sum_{i\in[0..h]}2^i\), which is \(2^{1+h}-1\), elements.
\item
  \begin{itemize}
  \item Heap sort is not stable, because \texttt{heapify} tends to mix up elements found at the bottom of the heap.
  \item Insert sort, selection sort, bubble sort, mergesort, quicksort, counting sort, bucket sort and radix sort are stable.
  \item Binary insert sort is not stable, but can be made stable by making sure that inserted elements are inserted at the end of a run of elements equal to it (costing a few comarisons, but saving on swaps).
  \end{itemize}
\item For heap sort to run in \(o(n\cdot\lg n)\) time, both the construction and destruction of the heap must run in \(o(n\cdot\lg n)\) time. For construction to run in \(o(n\cdot\lg n)\),
\end{enumerate}

\section{Counting sort}
The complexity of counting sort can be described as \(O(r\cdot n)\), where \(r\) is the number of elements in the range. When \(r\gg n\), as in many situations, counting sort will have worse than quadratic complexity.

\begin{minipage}{\linewidth}
\section{Fibonacci's sequence}
\begin{lstlisting}
-- Idris
fib : Nat -> Nat
fib Z         = 1
fib (S Z)     = 1
fib (S (S n)) = fib n + fib (S n)
\end{lstlisting}
This can be made to count how many times it calls itself by modifying it as follows.
\begin{lstlisting}
data Counted a = MkCounted Nat a
instance Functor Counted where
  map m (MkCounted k x) = MkCounted k (m x)
instance Applicative Counted where
  pure x = MkCounted 0 x
  (<$>) (MkCounted k x) (MkCounted j y) = MkCounted (S k + j) (x y) --$

fibC : Nat -> Counted Nat
fibC Z         = [| 1 |]
fibC (S Z)     = [| 1 |]
fibC (S (S n)) = [| fibC n + fibC (S n) |]
\end{lstlisting}
\end{minipage}
\begin{minipage}{\linewidth}
\texttt{fibC 10} yields \texttt{MkCounted 176 89} (176 recursive calls) and \texttt{fibC 20} (after some time) yields \texttt{MkCounted 21890 10946} (21890 recursive calls). Trying to evaluate \texttt{fibC 30} has already frozen my computer for long periods twice, so instead I will write a new function to calculate it:
\begin{lstlisting}
fibC' : Nat -> Int
fibC' = f (0,0)
  where
    f : (Int,Int) -> Nat -> Int
    f (a,b) Z = a
    f (a,b) (S k) = f (b,2 + a + b) k
\end{lstlisting}
With this, \texttt{fibC' 30} yields \texttt{2692536}. (There seems to be a bug in Idris' handling of \texttt{Nat}s, which it should optimise to GMP integers.)
\end{minipage}

\section{Dynamic programming}
\begin{enumerate}
\item The expression \(\begin{pmatrix}x_0&x_1&x_2\end{pmatrix}\cdot\left(\begin{pmatrix}y_0&y_1\\y_2&y_3\\y_4&y_5\end{pmatrix}\cdot\begin{pmatrix}z_0\\z_1\end{pmatrix}\right)\) reduces to \((x_0\cdot(y_0\cdot z_0+y_1\cdot z_1)+x_1\cdot(y_2\cdot z_0+y_3\cdot z_1)+x_2\cdot(y_4\cdot z_0+y_4\cdot z_1))\), which contains 9 multiplications. The expression \(\left(\begin{pmatrix}x_0&x_1&x_2\end{pmatrix}\cdot\begin{pmatrix}y_0&y_1\\y_2&y_3\\y_4&y_5\end{pmatrix}\right)\cdot\begin{pmatrix}z_0\\z_1\end{pmatrix}\) reduces to \(((x_0\cdot y_0+x_1\cdot y_2+x_2\cdot y_4)\cdot z_0+(x_0\cdot y_1+x_1\cdot y_3+x_2\cdot y_5)\cdot z_1)\), which contains 8 multiplications.
\item A full parenthesization of a \(1\)-element expression uses no parentheses, since there are no operations to surround. A full parenthesization of an \(n\)-element expression, where \(n > 1\), contains a full parenthesization of the first \(m\) elements and the last \(n - m\) elements (\(m\in(0..n)\)), plus a pair of parentheses around the entire expression. Assuming that the statement is true for all suitable \(m\), this gives a total of \(m-1+n-m-1+1\), which is \(n-1\), pairs of parentheses. Hence, the statement is true by strong induction.
\item \begin{lstlisting}[language=python]
def lmis(xs):
    n = len(xs)
    # Assuming array with constant time access
    #
    cache = n * [n * [False]]
    def get(ps):
        cache[fromBinary(ps)]
    def set(ps, x):
        cache[fromBinary(ps)] = x
    
\end{lstlisting}
\end{enumerate}

\end{document}
