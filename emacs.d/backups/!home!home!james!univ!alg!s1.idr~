module s1
  --data Counted : Type -> Type where
  --  Terminate : b -> Counted b
  --  Call      : (a -> Counted b) -> a -> Counted b
  --  Combine   : (f : a -> b -> c) -> Counted a -> Counted b -> Counted c

  --count : Counted a -> Nat
  --count (Terminate x) = Z
  --count (Call f x) = S (count (f x))
  --count (Combine f x y) = count x + count y

  --value : Counted a -> a
  --value (Terminate x) = x
  --value (Call f x) = value (f x)
  --value (Combine f x y) = value (Terminate (f (value x) (value y)))

  --infixr 9 $
  --($) : (a -> b) -> a -> b
  --($) = apply

  --instance Functor Counted where
  --  map m (Terminate x) = Terminate (m x)
  --  map m (Call f x) = Combine (const m) (Terminate ()) (Call f x)
  --  map m (Combine f x y) = Combine (\a,b => m (f a b)) x y
  ----instance Applicative Counted where
  ----  pure x = Terminate x
  ----  (<$>) (Terminate x) y = map x y
  ----  (<$>) (Call f x) y = Combine id (Call f x) y
  ----  (<$>) x (Terminate y) = map ($ y) x
  ----  (<$>) (Combine f x z) (Call g y) = ?rhs_2
  ----  (<$>) (Combine f x z) (Combine g y w) = ?rhs_3

  --fibC : Nat -> Counted Nat
  --fibC Z = Terminate 1
  --fibC (S Z) = Terminate 1
  --fibC (S (S k)) = Combine (+) (Call fibC k) (Call fibC (S k))

  data Counted a = MkCounted Nat a
  instance Functor Counted where
    map m (MkCounted k x) = MkCounted k (m x)
  instance Applicative Counted where
    pure x = MkCounted 0 x
    (<$>) (MkCounted k x) (MkCounted j y) = MkCounted (S k + j) (x y)

  fibC : Nat -> Counted Nat
  fibC Z         = [| 1 |]
  fibC (S Z)     = [| 1 |]
  fibC (S (S k)) = [| fibC k + fibC (S k) |]

  fibN : Nat -> Nat
  fibN Z = 0
  fibN (S Z) = 0
  fibN (S (S k)) = S (fibN k) + S (fibN (S k))

  fibC' : Nat -> Nat
  fibC' = f (0,0)
    where
      f : (Nat,Nat) -> Nat -> Nat
      f (a,b) Z = a
      f (a,b) (S k) = f (b,2 + a + b) k

  fibC'' : Nat -> Integer
  fibC'' = f (0,0)
    where
      f : (Integer,Integer) -> Nat -> Integer
      f (a,b) Z = a
      f (a,b) (S k) = f (b,2 + a + b) k
