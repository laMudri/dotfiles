module inductive
data Ind : (a -> Type) -> List a -> Type where
    NilInd : {p : a -> Type} -> Ind (const ()) []
    ConsInd : {p : a -> Type} -> {q : a -> Type} -> p x -> q x -> Ind p xs ->
              Ind (\y => (p y,q y)) (x :: xs)

data All : (a -> Type) -> List a -> Type where
    NilAll : {p : a -> Type} -> All p []
    ConsAll : {p : a -> Type} -> p x -> All p xs -> All p (x :: xs)

data Increasing : Ord a => (a : Type) -> (xs : Stream a) -> Type where
    ConsInc : Ord a => (x : a) -> {default Oh p : So (x < y)} ->
              IncreasingList a (y :: ys) -> IncreasingList a (x :: y :: ys)

data IncreasingList : Ord a => (a : Type) -> (xs : List a) -> Type where
    SingleIncL : Ord a => (x : a) -> IncreasingList a [x]
    ConsIncL : Ord a => (x : a) -> {default Oh p : So (x < y)} ->
               IncreasingList a (y :: ys) -> IncreasingList a (x :: y :: ys)

data RelatedList : (a : Type) -> (a -> a -> Type) -> (xs : List a) ->
                   Type where
    SingleRelL : (x : a) -> (r : a -> a -> Type) -> RelatedList a r [x]
    ConsRelL : (x : a) -> (r : a -> a -> Type) -> {default Oh p : x `r` y} ->
               RelatedList a r (y :: ys) -> RelatedList a r (x :: y :: ys)

{-data Any : (a -> Type) -> List a -> Type where
     NilAny : {p : a -> Type} -> Any p []
     ConsAny : {p : a -> Type} -> Either (p x,the (List _) (x :: xs)) (Any p xs) -> Any p (x :: xs)-}
