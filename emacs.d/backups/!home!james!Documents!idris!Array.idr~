module Array
import Data.Vect
import Data.Fin
%default total

data Array : Vect n Nat -> Type -> Type where
  MkScalar : a -> Array [] a
  MkArray : Vect n (Array ns a) -> Array (n::ns) a
%name Array xs,ys,zs

-- Array [0] Int is like ()
-- Array [] Int is like Int
-- Array [4] Int is like Vect 4 Int
-- Array [3,4] Int is like Vect 3 (Vect 4 Int)

scalarMap : (a -> b) -> Array s a -> Array s b
scalarMap f (MkScalar x) = MkScalar (f x)
scalarMap f (MkArray xs) = MkArray (map (scalarMap f) xs)

replicate : (s : Vect _ Nat) -> a -> Array s a
replicate [] x = MkScalar x
replicate (y :: xs) x = MkArray (replicate _ (replicate _ x))

data VarVect : (n : Nat) -> (Vect n Type) -> Type where
  VarNil : VarVect Z []
  VarCons : t -> VarVect n ts -> VarVect (S n) (t :: ts)

index : (i : VarVect n (map Fin s)) -> Array s a -> a
index _ (MkScalar x) = x
index (VarCons x xs) (MkArray ys) = index xs (index x ys)

instance Functor (Array s) where
  map = scalarMap

instance Applicative (Array s) where
  pure = replicate _
  (MkScalar f) <*> (MkScalar x) = MkScalar (f x)
  (MkArray fs) <*> (MkArray xs) = MkArray (zipWith (<*>) fs xs)

zipWith : (a -> b -> c) -> Array s a -> Array s b -> Array s c
zipWith f x y = pure f <*> x <*> y

vectIotaFin : (n : Nat) -> Vect n (Fin n)
vectIotaFin Z = []
vectIotaFin (S n) = FZ :: map FS (vectIotaFin n)

coordsFin : {s : Vect n Nat} -> Array s (VarVect n (map Fin s))
coordsFin {s = []} = MkScalar VarNil
coordsFin {s = (x :: xs)} =
  MkArray (map (\y => map (VarCons y) (coordsFin {s = xs}))
               (vectIotaFin x))

diag : Array s (Array s a) -> Array s a
diag = zipWith index coordsFin

instance Monad (Array s) where
  m >>= f = diag (map f m)

-- Typeclass instances end

cons : Array ns a -> Array (n::ns) a -> Array (S n::ns) a
cons x (MkArray xs) = MkArray (x::xs)

head : Array (S n::ns) a -> Array ns a
head (MkArray (x :: xs)) = x

behead : Array (S n::ns) a -> Array (n::ns) a
behead (MkArray (x :: xs)) = MkArray xs

iota : (n : Nat) -> Array [n] Nat
iota Z = MkArray []
iota (S k) = cons (MkScalar 0) (scalarMap S (iota k))

data ZipProof : (a -> b -> Type) -> Vect n a -> Vect n b -> Type where
  NilProof : ZipProof f [] []
  ConsProof : (x : a) -> (y : b) -> {auto p : f x y} ->
              ZipProof f xs ys -> ZipProof f (x :: xs) (y :: ys)

natToFinProven : (m : Nat) -> (n : Nat) -> (p : m `LT` n) -> Fin n
natToFinProven Z (S _) _ = FZ
natToFinProven (S i) (S j) (LTESucc x) = FS (natToFinProven i j x)

index' : (i : Vect n Nat) -> {auto p : ZipProof LT i s} -> Array s a -> a
index' _ (MkScalar y) = y
index' (i :: is) {p = ConsProof i n {p = p} z} (MkArray xs) =
  index' is (index (natToFinProven i n p) xs)

app : {s : Vect _ Nat} -> {t : Vect _ Nat} ->
      (Array s a -> Array t b) -> Array (r ++ s) a -> Array (r ++ t) b
app {r = []} f x = f x
app {r = (_ :: _)} f (MkArray xs) = MkArray (map (app f) xs)

vectIota : (n : Nat) -> Vect n Nat
vectIota Z = []
vectIota (S k) = Z :: map S (vectIota k)

coordinates : (s : Vect n Nat) -> Array s (Vect n Nat)
coordinates [] = MkScalar []
coordinates (x :: xs) = MkArray (map (\y => map (y ::) (coordinates xs))
                                     (vectIota x))

vectToArray : Vect n a -> Array [n] a
vectToArray xs = MkArray (map MkScalar xs)

vect2ToArray : Vect m (Vect n a) -> Array [m,n] a
vect2ToArray xs = MkArray (map vectToArray xs)
