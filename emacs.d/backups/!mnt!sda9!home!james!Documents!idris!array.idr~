module array

data Array : Vect n Nat -> Type -> Type where
     mkScalar : a -> Array [] a
     mkArray : Vect n (Array ns a) -> Array (n::ns) a

-- Array [0] Int is like ()
-- Array [] Int is like Int
-- Array [4] Int is like Vect 4 Int
-- Array [3,4] Int is like Vect 3 (Vect 4 Int)

cons : Array ns a -> Array (n::ns) a -> Array (S n::ns) a
cons x (mkArray xs) = mkArray (x::xs)

head : Array (S n::ns) a -> Array ns a
head (mkArray (x :: xs)) = x
     
behead : Array (S n::ns) a -> Array (n::ns) a
behead (mkArray (x :: xs)) = mkArray xs

scalarMap : (a -> b) -> Array s a -> Array s b
scalarMap f (mkScalar x) = mkScalar (f x)
scalarMap f (mkArray xs) = mkArray (map (scalarMap f) xs)

replicate : (s : Vect _ Nat) -> a -> Array s a
replicate [] x = mkScalar x
replicate (y :: xs) x = mkArray (replicate _ (replicate _ x))

iota : (n : Nat) -> Array [n] Nat
iota Z = mkArray []
iota (S k) = cons (mkScalar 0) (scalarMap S (iota k))

diag : Array s (Array s a) -> Array s a
diag (mkScalar (mkScalar x)) = mkScalar x
diag (mkArray xs) = ?diag_rhs --diag (mkArray $ map tail xs)

instance Functor (Array s) where
         map = scalarMap
         
instance Applicative (Array s) where
         pure = replicate _

         (mkScalar f) <$> (mkScalar x) = mkScalar (f x)
         (mkArray fs) <$> (mkArray xs) = mkArray (zipWith (<$>) fs xs)

instance Monad (Array s) where
         m >>= f = diag (map f m)

vectIota : (n : Nat) -> Vect n Nat
vectIota Z = []
vectIota (S k) = Z :: map S (vectIota k)

coordinates : (s : Vect n Nat) -> Array s (Vect n Nat)
coordinates [] = mkScalar []
coordinates (x :: xs) = mkArray (map (\y => map (y ::) (coordinates xs)) (vectIota x))

zipWith : (a -> b -> c) -> Array s a -> Array s b -> Array s c
zipWith f x y = pure f <$> x <$> y

-- coordinates [2,3] =
--   [0,0] [0,1] [0,2]
--   [1,0] [1,1] [1,2]
-- coordinates [3] =
--   [0] [1] [2]
-- coordinates [] =
--   []
