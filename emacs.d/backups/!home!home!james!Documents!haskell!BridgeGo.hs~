{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE UnicodeSyntax #-}
module BridgeGo where
  import Data.Monoid
  --import Data.Maybe
  import Data.List
  import Data.Set (Set)
  import qualified Data.Set as S
  import Prelude.Unicode
  --import Data.Set.Unicode as S
  --import Control.Monad
  
  type Moku = Maybe Player
  data Board = Board Int (Position → Moku)
  newtype Player = Player Bool
  type Position = (Int,Int)
  data Result = Win Player Board
              | NoResult Player Board
              | Illegal Player Board String
  data Chain = Chain Player (Set Position)
  
  playFrom ∷ Player → Board → (Set Chain) → [Position] → Result
  playFrom = undefined
  playAt ∷ Player → Board → (Set Chain) → Position → Result
  playAt = undefined
  liberties ∷ Position → [Position]
  liberties = undefined
  chainFromPoint ∷ Board → Position → Chain
  chainFromPoint (Board size f) p = Chain player points
    where
      player = case f p of
                 Just pl → pl
                 Nothing → error "No stone there"
      points = case find (isPointInSpace p)
                       $ S.elems (falseSpaces size ((≢ player) ∘ f)) of
                 Just (Space ps _) = ps
                 Nothing = error "Eh?"
  
  data Side = LeftS | TopS | RightS | BottomS deriving (Eq,Ord,Show)
  data Space = Space (Set Position) (Set Side)
               deriving (Show,Eq,Ord)
  instance Monoid Space where
    mempty = Space mempty mempty
    Space ps0 ss0 `mappend` Space ps1 ss1 = Space (ps0 <> ps1) (ss0 <> ss1) 

  atEdge ∷ Int → Side → Position → Bool
  atEdge _ LeftS (x,_) = x ≡ 0
  atEdge _ TopS (_,y) = y ≡ 0
  atEdge size RightS (x,_) = x ≡ pred size
  atEdge size BottomS (_,y) = y ≡ pred size

  pointSpace ∷ Int → (Position → Bool) → Position → Space
  pointSpace size f p =
    if g p
       then Space mempty mempty
       else Space (S.singleton p)
                  (mconcat (map (\s → if atEdge size s p then S.singleton s
                                                         else mempty) edges))
    where g q@(x,y) = 0 ≤ x ∧ x < size ∧ 0 ≤ y ∧ y < size ∧ f q
          edges = [LeftS,TopS,RightS,BottomS]

  externalSpace ∷ Space → Bool
  externalSpace (Space _ ss) = (f LeftS ∧ f RightS) ∨ (f TopS ∧ f BottomS)
    where f = (`S.member` ss)

  falseSpaces ∷ Int → (Position → Bool) → Set Space
  falseSpaces size f = go mempty (Just (0,0))
    where
      go ∷ Set Space → Maybe Position → Set Space
      go ss Nothing = ss
      go ss (Just p)
         | f p = go ss (next p)
         | otherwise = go ss'' (next p)
         where
           psp = pointSpace size f
           spaceLeft = find (\(Space ps _) → step LeftS p `S.member` ps)
                            (S.elems ss)
           spaceTop = find (\(Space ps _) → step TopS p `S.member` ps)
                           (S.elems ss)
           interspace = case spaceLeft of
                          Just s → psp p <> s
                          Nothing → psp p
           ss' = case spaceLeft of
                   Just s → S.insert interspace (S.delete s ss)
                   Nothing → S.insert interspace ss
           ss'' = case spaceTop of
                    Just s → S.insert (interspace <> s) $ S.delete interspace
                                                        $ S.delete s ss'
                    Nothing → ss'

      step ∷ Side → Position → Position
      step LeftS (x,y) = (pred x,y)
      step TopS (x,y) = (x,pred y)
      step RightS (x,y) = (succ x,y)
      step BottomS (x,y) = (x,succ y)

      next ∷ Position → Maybe Position
      next (x,y)
           | x' ≡ size = if succ y ≡ size then Nothing else Just (0,succ y)
           | otherwise = Just (x',y)
           where x' = succ x

  external ∷ Int → (Position → Bool) → Position → Bool
  external size f q = not (f q) ∧ case find (\(Space ps _) → q `S.member` ps)
                                            (S.elems (falseSpaces size f)) of
                                    Just s → externalSpace s
                                    Nothing → error "Eh?"
